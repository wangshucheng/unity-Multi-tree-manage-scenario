# unity-Multi-tree-manage-scenario

unity 四叉树管理场景

当场景元素过多时，需要实时的显示及隐藏物体使得性能提示，但是物体那么多，怎么知道哪些物体需要显示，哪些物体不需要显示的。当然，遍历物体判断该物体是否可以显示是最容易想到的方法，但是每次更新要遍历所有物体的代价很高，有没有其他可以替代的方法呢，当然有，四叉树就是其中一个方法。

假设场景是一维的，所有物体从左到右排成一条线，那么用二分法就可以快速找出距离自己一定范围内的物体。

同样四叉树的原理像二分一样，只是二分法处理的是一维世界， 四叉树处理的是二维世界，再往上三维世界用八叉树处理，这里用四叉树管理，八叉树暂时不讨论，原理类似。

这里先展示效果：



四叉树结构：

根节点是整个场景区域，然后分成四块：左上右上左下右下，分别作为根节点的儿子，然后每个儿子又分成四块重复之前步骤，这就是一棵四叉树。

每个节点保存四个儿子节点的引用，并且有存放在自己节点的物体列表，为什么物体不全部存放在叶子节点呢？因为有可能某个物体比较大，刚好在两个块的边界上。

这时候有两种做法：

1、这个物体同时插入两个节点的物体列表中

2、这个物体放在两个几点的父亲节点的物体列表中

第一种方法管理起来比较麻烦，所以在此采用第二种方法。

首先定义场景物体的数据类：ObjData

定义节点的接口：INode

定义节点：Node 

一棵完整的树：Tree 

初始化场景物体时，对于每个物体，需要插入四叉树中：判断该物体属于根节点的哪个儿子中，如果有多个儿子都可以包含这个物体，那么这个物体属于该节点，否则属于儿子，进入儿子中重复之前的步骤。

代码如下：void InsertObj(ObjData obj)

当role走动的时候，需要从四叉树中找到并创建摄像机可以看到的物体：void TriggerMove(Camera camera)

游戏运行的一开始，先构造四叉树，并把场景物体的数据插入四叉树中由四叉树管理数据：Main 

每次玩家移动则创建物体：Main -> void Update()

怎么计算出某个节点的bound是否与摄像机交叉呢？

 

我们知道，渲染管线是局部坐标系=》世界坐标系=》摄像机坐标系=》裁剪坐标系=》ndc-》屏幕坐标系，其中在后三个坐标系中可以很便捷的得到某个点是否处于摄像机可视范围内。

在此用裁剪坐标系来判断，省了几次坐标转换，判断某个点在摄像机可视范围内方法如下：

将该点转换到裁剪空间，得到裁剪空间中的坐标为vec(x,y,z,w)，那么如果-w<x<w&&-w<y<w&&-w<z<w，那么该点在摄像机可视范围内。

对bound来说，它有8个点，当它的8个点同时处于摄像机裁剪块上方/下方/前方/后方/左方/右方，那么该bound不与摄像机可视范围交叉

代码如下：bool CheckBoundIsInCamera(this Bounds bound, Camera camera)

以上是物体的创建，物体的消失放在resourcesmanager中。

建立两个字典分别保存当前显示的物体，和当前隐藏的物体：ResourcesManager 

开启一段协程，每过一段时间就删除在隐藏字典中的物体：IEDel

每次triggerMove创建物体后刷新资源状态，将此次未进入节点（status = old）的物体从显示字典中移到隐藏字典中，并将此次进入节点（status = new）的物体标记为old为下次创建做准备：void RefreshStatus()

至此，比较简单的四叉树就完毕了。

更复杂的四叉树还需要实现物体在节点之间移动，比如物体是动态的可能从某个节点块移动到另个节点块；物体不消失而用LOD等，在此就不讨论了
